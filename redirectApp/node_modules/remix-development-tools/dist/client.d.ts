import * as react_jsx_runtime from 'react/jsx-runtime';
import { FormEncType } from '@remix-run/react';

interface RemixForgeMessage extends Record<string, unknown> {
    subtype: "read_file" | "open_file" | "delete_file" | "write_file";
    path: string;
    data?: string;
}
declare const useRemixForgeSocketExternal: (options?: any) => {
    isConnected: boolean;
    isConnecting: boolean;
    sendJsonMessage: (message: RemixForgeMessage) => void;
};

interface RDTEvent<Type extends string, Data extends Record<string, unknown> | any[]> {
    type: Type;
    data: Data;
}
type LoaderEvent = RDTEvent<"loader", {
    id: string;
    executionTime: number;
    requestData: any;
    responseData: any;
    requestHeaders: Record<string, string>;
    responseHeaders: Record<string, string>;
    timestamp: number;
}>;
type ActionEvent = RDTEvent<"action", {
    id: string;
    executionTime: number;
    requestData: any;
    responseData: any;
    requestHeaders: Record<string, string>;
    responseHeaders: Record<string, string>;
    timestamp: number;
}>;

type Tabs = (typeof tabs)[number]["id"];
interface Tab {
    name: string | JSX.Element;
    icon: JSX.Element;
    id: string;
    component: JSX.Element;
    requiresForge: boolean;
    hideTimeline: boolean;
}
declare const tabs: readonly [{
    readonly name: "Active page";
    readonly icon: react_jsx_runtime.JSX.Element;
    readonly id: "page";
    readonly component: react_jsx_runtime.JSX.Element;
    readonly requiresForge: false;
    readonly hideTimeline: false;
}, {
    readonly name: "Routes";
    readonly icon: react_jsx_runtime.JSX.Element;
    readonly id: "routes";
    readonly component: react_jsx_runtime.JSX.Element;
    readonly requiresForge: false;
    readonly hideTimeline: false;
}, {
    readonly name: "Terminal";
    readonly icon: react_jsx_runtime.JSX.Element;
    readonly id: "terminal";
    readonly component: react_jsx_runtime.JSX.Element;
    readonly requiresForge: true;
    readonly hideTimeline: false;
}, {
    readonly name: "Errors";
    readonly icon: react_jsx_runtime.JSX.Element;
    readonly id: "errors";
    readonly component: react_jsx_runtime.JSX.Element;
    readonly requiresForge: false;
    readonly hideTimeline: false;
}, {
    readonly name: "Settings";
    readonly icon: react_jsx_runtime.JSX.Element;
    readonly id: "settings";
    readonly component: react_jsx_runtime.JSX.Element;
    readonly requiresForge: false;
    readonly hideTimeline: false;
}];

interface TerminalOutput {
    type: "output" | "command" | "error";
    value: string;
}
interface Terminal {
    id: number;
    locked: boolean;
    history: string[];
    output: TerminalOutput[];
    processId?: number;
}

interface NormalRedirectEvent {
    type: "REDIRECT";
    to: string;
    search: string;
    hash: string;
    method: "GET";
    id: string;
    responseData?: Record<string, any>;
}
interface FetcherRedirectEvent extends Omit<NormalRedirectEvent, "type"> {
    type: "FETCHER_REDIRECT";
}
interface FetcherSubmissionEvent extends Omit<FormSubmissionEvent, "type" | "from"> {
    type: "FETCHER_SUBMIT";
    key?: string;
    responseData?: Record<string, any>;
}
interface FetcherSubmissionResponseEvent extends Omit<FormSubmissionEvent, "type" | "from"> {
    type: "FETCHER_RESPONSE";
    key?: string;
    responseData?: Record<string, any>;
}
interface FormSubmissionEvent {
    type: "FORM_SUBMISSION";
    id: string;
    to: string;
    data?: Record<string, any>;
    responseData?: Record<string, any>;
    method: "get" | "post" | "put" | "patch" | "delete" | "GET" | "POST" | "PUT" | "PATCH" | "DELETE";
    from: string;
    encType?: FormEncType;
}
interface ActionRedirectEvent extends Omit<FormSubmissionEvent, "type"> {
    type: "ACTION_REDIRECT";
}
interface ActionResponseEvent extends Omit<FormSubmissionEvent, "type"> {
    type: "ACTION_RESPONSE";
}
type RedirectEvent = NormalRedirectEvent | FetcherRedirectEvent;
type FormEvent = FormSubmissionEvent | FetcherSubmissionEvent | ActionRedirectEvent | FetcherSubmissionResponseEvent | ActionResponseEvent;
type TimelineEvent = RedirectEvent | FormEvent;

declare const ROUTE_BOUNDARY_GRADIENTS: {
    readonly sea: "sea-gradient";
    readonly hyper: "hyper-gradient";
    readonly gotham: "gotham-gradient";
    readonly gray: "gray-gradient";
    readonly watermelon: "watermelon-gradient";
    readonly ice: "ice-gradient";
    readonly silver: "silver-gradient";
};
type RouteWildcards = Record<string, Record<string, string> | undefined>;
type TriggerPosition = "top-left" | "top-right" | "bottom-left" | "bottom-right" | "middle-left" | "middle-right";
type ServerRouteInfo = {
    actions?: Omit<ActionEvent["data"], "id">[];
    loaders?: Omit<LoaderEvent["data"], "id">[];
    lowestExecutionTime: number;
    highestExecutionTime: number;
    averageExecutionTime: number;
    loaderTriggerCount: number;
    actionTriggerCount: number;
    lastAction: Partial<Omit<ActionEvent["data"], "id">>;
    lastLoader: Partial<Omit<LoaderEvent["data"], "id">>;
};
type ServerInfo = {
    port?: number;
    routes?: {
        [key: string]: ServerRouteInfo;
    };
};
type HTMLErrorPrimitive = {
    file: string;
    tag: string;
};
type HTMLError = {
    child: HTMLErrorPrimitive;
    parent: HTMLErrorPrimitive;
};
type RemixDevToolsState = {
    timeline: TimelineEvent[];
    terminals: Terminal[];
    settings: {
        /**
         * The breakpoints to show in the corner so you can see the current breakpoint that you defined
         */
        breakpoints: {
            name: string;
            min: number;
            max: number;
        }[];
        /**
         * Whether to show the breakpoint indicator
         */
        showBreakpointIndicator: boolean;
        /**
         * The live urls to show in the corner which allow you to open the app in a different environment (eg. staging, production)
         * @default []
         */
        liveUrls: {
            url: string;
            name: string;
        }[];
        /**
         * The position of the live urls
         * @default "bottom-left"
         */
        liveUrlsPosition: "bottom-left" | "bottom-right" | "top-left" | "top-right";
        /**
         * The route boundary gradient color to use
         * @default "silver"
         */
        editorName: string;
        /**
         * The route boundary gradient color to use
         * @default "watermelon"
         */
        routeBoundaryGradient: keyof typeof ROUTE_BOUNDARY_GRADIENTS;
        routeWildcards: RouteWildcards;
        activeTab: Tabs;
        shouldConnectWithForge: boolean;
        port: number;
        height: number;
        /**
         * The maximum height of the panel
         * @default 800
         */
        maxHeight: number;
        /**
         * The minimum height of the panel
         * @default 200
         */
        minHeight: number;
        /**
         * Whether the dev tools should be open by default
         * @default false
         */
        defaultOpen: boolean;
        /**
         * Whether the dev tools trigger should be hidden until the user hovers over it
         * @default false
         */
        hideUntilHover: boolean;
        /**
         * The position of the trigger button
         * @default "bottom-right"
         */
        position: TriggerPosition;
        /**
         * The initial expansion level of the JSON viewer objects
         * @default 1
         */
        expansionLevel: number;
        hoveredRoute: string;
        isHoveringRoute: boolean;
        routeViewMode: "list" | "tree";
        /**
         * The location of the panel once it is open
         * @default "bottom"
         */
        panelLocation: "top" | "bottom";
        withServerDevTools: boolean;
        /**
         * The hotkey to open the dev tools
         * @default "shift+a"
         */
        openHotkey: string;
        /**
         * Whether to require the URL flag to open the dev tools
         * @default false
         */
        requireUrlFlag: boolean;
        /**
         * The URL flag to open the dev tools, used in conjunction with requireUrlFlag (if set to true)
         * @default "rdt"
         */
        urlFlag: string;
        /**
         * Whether to show route boundaries on hover of the route segment or clicking a button
         */
        showRouteBoundariesOn: "hover" | "click";
    };
    htmlErrors: HTMLError[];
    server?: ServerInfo;
    persistOpen: boolean;
    detachedWindow: boolean;
    detachedWindowOwner: boolean;
};

type RdtClientConfig = Pick<RemixDevToolsState["settings"], "defaultOpen" | "breakpoints" | "showBreakpointIndicator" | "showRouteBoundariesOn" | "expansionLevel" | "liveUrls" | "position" | "height" | "minHeight" | "maxHeight" | "hideUntilHover" | "panelLocation" | "requireUrlFlag" | "urlFlag" | "routeBoundaryGradient">;

interface DevToolsServerConfig {
    /**
     * Whether to log in the console, this turns off ALL logging
     * If you want to be granulat use the logs option
     * @default true
     */
    silent?: boolean;
    /**
     * The threshold for server timings to be logged in the console
     * If the server timing is greater than this threshold, it will be logged in red, otherwise it will be logged in green
     * @default Number.POSITIVE_INFINITY
     *
     */
    serverTimingThreshold?: number;
    logs?: {
        /**
         * Whether to log cookie headers in the console
         * @default true
         */
        cookies?: boolean;
        /**
         * Whether to log deferred loaders  in the console
         * @default true
         */
        defer?: boolean;
        /**
         * Whether to log action calls in the console
         * @default true
         * */
        actions?: boolean;
        /**
         * Whether to log loader calls in the console
         * @default true
         */
        loaders?: boolean;
        /**
         * Whether to log cache headers in the console
         * @default true
         */
        cache?: boolean;
        /**
         * Whether to log site clear headers in the console
         * @default true
         */
        siteClear?: boolean;
        /**
         * Whether to log server timings headers in the console
         * @default true
         */
        serverTimings?: boolean;
    };
}
declare global {
    namespace NodeJS {
        interface Process {
            rdt_config: DevToolsServerConfig;
            rdt_port: number;
        }
    }
}

declare global {
    interface Window {
        RDT_MOUNTED: boolean;
    }
    namespace NodeJS {
        interface Process {
            rdt_config: DevToolsServerConfig;
            rdt_port: number;
        }
    }
}

type RdtPlugin = (...args: any) => Tab;

interface RemixDevToolsProps {
    plugins?: (Tab | RdtPlugin)[];
    config?: RdtClientConfig;
}

interface EmbeddedDevToolsProps extends RemixDevToolsProps {
    mainPanelClassName?: string;
    className?: string;
}
declare const EmbeddedDevTools: ({ plugins, mainPanelClassName, className }: EmbeddedDevToolsProps) => react_jsx_runtime.JSX.Element | null;

declare const defineClientConfig: (config: RdtClientConfig) => RdtClientConfig;
declare const withDevTools: (Component: any, config?: RemixDevToolsProps) => () => react_jsx_runtime.JSX.Element;
/**
 *
 * @description Injects the dev tools into the Vite App, ONLY meant to be used by the package plugin, do not use this yourself!
 */
declare const withViteDevTools: (Component: any, config?: RemixDevToolsProps) => () => (props: any) => react_jsx_runtime.JSX.Element;

export { EmbeddedDevTools, defineClientConfig, useRemixForgeSocketExternal as useRemixForgeSocket, withDevTools, withViteDevTools };
