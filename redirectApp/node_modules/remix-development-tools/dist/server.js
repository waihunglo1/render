// src/server/config.ts
var defineServerConfig = (config) => config;
var getConfig = () => process.rdt_config;

// src/server/utils.ts
import chalk2 from "chalk";

// src/server/logger.ts
import chalk from "chalk";
var log = (message) => {
  const config = getConfig();
  if (config.silent) {
    return;
  }
  console.log(message);
};
var errorLog = (message) => {
  log(`${chalk.redBright.bold("ERROR")} ${message}`);
};
var redirectLog = (message) => {
  log(`${chalk.yellowBright.bold("REDIRECT")} ${message}`);
};
var infoLog = (message) => {
  log(`${chalk.blueBright.bold("INFO")} ${message}`);
};
var loaderLog = (message) => {
  const config = getConfig();
  if (config.logs?.loaders === false) {
    return;
  }
  log(`${chalk.green.bold("LOADER")} ${message}`);
};
var actionLog = (message) => {
  const config = getConfig();
  if (config.logs?.actions === false) {
    return;
  }
  log(`${chalk.yellowBright.bold("ACTION")} ${message}`);
};

// src/server/perf.ts
var diffInMs = (start, end = performance.now()) => Number((end - start).toFixed(2));
var secondsToHuman = (s) => {
  if (s > 3600) {
    const hours = Math.floor(s / 3600);
    const minutes = Math.floor(s % 3600 / 60);
    const seconds = Math.floor(s % 3600 % 60);
    if (minutes === 0 && seconds === 0)
      return `${hours}h`;
    if (seconds === 0)
      return `${hours}:${minutes}h`;
    return `${hours}:${minutes}:${seconds}h`;
  }
  if (s > 60) {
    const minutes = Math.floor(s / 60);
    const seconds = Math.floor(s % 60);
    if (seconds === 0)
      return `${minutes}m`;
    return `${minutes}:${seconds}m`;
  }
  return `${s}s`;
};

// src/server/utils.ts
var analyzeCookies = (route, config, headers) => {
  if (config.logs?.cookies === false) {
    return;
  }
  if (headers.get("Set-Cookie")) {
    infoLog(`\u{1F36A} Cookie set by ${chalk2.blueBright(route.id)}`);
  }
};
var analyzeCache = (route, config, headers) => {
  if (config.logs?.cache === false) {
    return;
  }
  if (headers.get("Cache-Control")) {
    const cacheDuration = headers.get("Cache-Control")?.split(" ").map((x) => x.trim().replace(",", ""));
    const age = cacheDuration?.find((x) => x.includes("max-age"));
    const serverAge = cacheDuration?.find((x) => x.includes("s-maxage"));
    const isPrivate = cacheDuration?.find((x) => x.includes("private"));
    if (age && serverAge && !isPrivate) {
      const duration = serverAge.split("=")[1];
      const durationNumber = Number.isNaN(Number.parseInt(duration)) ? 0 : Number.parseInt(duration);
      return infoLog(
        `\u{1F4E6} Route ${chalk2.blueBright(route.id)} cached for ${chalk2.green(secondsToHuman(durationNumber))} ${chalk2.green(
          "[Shared Cache]"
        )}`
      );
    }
    if (age) {
      const duration = age.split("=")[1];
      const durationNumber = Number.isNaN(Number.parseInt(duration)) ? 0 : Number.parseInt(duration);
      infoLog(
        `\u{1F4E6} Route ${chalk2.blueBright(route.id)} cached for ${chalk2.green(secondsToHuman(durationNumber))} ${chalk2.green(
          `[${isPrivate ? "Private Cache" : "Shared Cache"}]`
        )}`
      );
    }
    if (serverAge) {
      const duration = serverAge.split("=")[1];
      const durationNumber = Number.isNaN(Number.parseInt(duration)) ? 0 : Number.parseInt(duration);
      infoLog(
        `\u{1F4E6} Route ${chalk2.blueBright(route.id)} cached for ${chalk2.green(secondsToHuman(durationNumber))} ${chalk2.green(
          "[Shared Cache]"
        )}`
      );
    }
  }
};
var analyzeClearSite = (route, config, headers) => {
  if (config.logs?.siteClear === false) {
    return;
  }
  if (headers.get("Clear-Site-Data")) {
    const data = headers.get("Clear-Site-Data");
    infoLog(`\u{1F9F9} Site data cleared by ${chalk2.blueBright(route.id)} ${chalk2.green(`[${data}]`)}`);
  }
};
var analyzeServerTimings = (route, config, headers) => {
  if (config.logs?.serverTimings === false) {
    return;
  }
  const data = headers.get("Server-Timing");
  if (data) {
    const splitEntries = data.split(",");
    for (const entry of splitEntries) {
      const segments = entry.split(";");
      let name = null;
      let desc = null;
      let dur = null;
      for (const segment of segments) {
        const [key, value] = segment.split("=");
        if (key === "desc") {
          desc = value;
        } else if (key === "dur") {
          dur = Number(value);
        } else {
          name = segment;
        }
      }
      if (!name || dur === null) {
        return;
      }
      const threshold = config.serverTimingThreshold ?? Number.POSITIVE_INFINITY;
      const overThreshold = dur > threshold;
      const durationColor = overThreshold ? chalk2.redBright : chalk2.green;
      infoLog(
        `\u23F0  Server timing for route ${chalk2.blueBright(route.id)} - ${chalk2.cyanBright(name)} ${durationColor(`[${dur}ms]`)} ${desc ? chalk2.yellow(`[${desc}]`) : ""}`
      );
    }
  }
};
var analyzeHeaders = (route, response) => {
  if (!(response instanceof Response)) {
    return;
  }
  const headers = new Headers(response.headers);
  const config = getConfig();
  analyzeCookies(route, config, headers);
  analyzeCache(route, config, headers);
  analyzeClearSite(route, config, headers);
  analyzeServerTimings(route, config, headers);
};
var analyzeDeferred = (id, start, response) => {
  const config = getConfig();
  if (config.logs?.defer === false) {
    return;
  }
  if (response?.deferredKeys) {
    infoLog(`Deferred values detected in ${chalk2.blueBright(id)} - ${chalk2.white(response.deferredKeys.join(", "))}`);
    response.deferredKeys.map((key) => {
      response.data[key].then(() => {
        const end = diffInMs(start);
        infoLog(`Deferred value ${chalk2.white(key)} resolved in ${chalk2.blueBright(id)} - ${chalk2.white(`${end}ms`)}`);
      }).catch((e) => {
        errorLog(`Deferred value ${chalk2.white(key)} rejected in ${chalk2.blueBright(id)}`);
        errorLog(e?.message ? e.message : e);
      });
    });
  }
};
var isAsyncFunction = (fn) => {
  return fn.constructor.name === "AsyncFunction";
};
var unAwaited = async (promise) => {
  promise();
};
function isResponseStub(value) {
  return value && typeof value === "object" && "headers" in value;
}
var errorHandler = (routeId, e, shouldThrow = false) => {
  unAwaited(() => {
    if (e instanceof Response || isResponseStub(e)) {
      const headers = new Headers(e.headers);
      const location = headers.get("Location");
      if (location) {
        redirectLog(`${chalk2.blueBright(routeId)} threw a response!`);
        redirectLog(`${chalk2.blueBright(routeId)} redirected to ${chalk2.green(location)}`);
      } else {
        errorLog(`${chalk2.blueBright(routeId)} threw a response!`);
        if (e.status) {
          errorLog(
            `${chalk2.blueBright(routeId)} responded with ${chalk2.white(e.status)} ${isResponseStub(e) ? "" : chalk2.white(e.statusText)}`
          );
        }
      }
    } else {
      errorLog(`${chalk2.blueBright(routeId)} threw an error!`);
      errorLog(`${e?.message}`);
    }
  });
  if (shouldThrow) {
    throw e;
  }
};
var logTrigger = (id, type, end) => {
  if (type === "action") {
    actionLog(`${chalk2.blueBright(id)} triggered - ${chalk2.white(`${end} ms`)}`);
  } else {
    loaderLog(`${chalk2.blueBright(id)} triggered - ${chalk2.white(`${end} ms`)}`);
  }
};
var extractHeadersFromResponseOrRequest = (response) => {
  const headers = new Headers(response.headers);
  return Object.fromEntries(headers.entries());
};
var storeAndEmitActionOrLoaderInfo = async (type, route, response, end, args) => {
  const isResponse = response instanceof Response;
  const isObject = typeof response === "object" && response !== null && !("deferredKeys" in response);
  const responseHeaders = isResponse ? extractHeadersFromResponseOrRequest(response) : null;
  const requestHeaders = extractHeadersFromResponseOrRequest(args.request);
  const event = {
    type,
    data: {
      id: route.id,
      executionTime: end,
      timestamp: (/* @__PURE__ */ new Date()).getTime(),
      ...isObject ? { responseData: response } : {},
      //requestData: await extractDataFromResponseOrRequest(args.request),
      requestHeaders,
      responseHeaders
    }
  };
  const port = process.rdt_port;
  if (port) {
    fetch(`http://localhost:${port}/remix-development-tools-request`, {
      method: "POST",
      body: JSON.stringify(event)
    }).then(() => {
    }).catch(() => {
    });
  }
};
var syncAnalysis = (route, type, loaderOrAction) => (args) => {
  const start = performance.now();
  try {
    const response = loaderOrAction(args);
    unAwaited(() => {
      const end = diffInMs(start);
      logTrigger(route.id, type, end);
      storeAndEmitActionOrLoaderInfo(type, route, response, end, args);
      analyzeHeaders(route, response);
    });
    return response;
  } catch (err) {
    errorHandler(route.id, err, true);
  }
};
var asyncAnalysis = (route, type, loaderOrAction) => async (args) => {
  const start = performance.now();
  const response = loaderOrAction(args);
  response.then((response2) => {
    unAwaited(() => {
      const end = diffInMs(start);
      storeAndEmitActionOrLoaderInfo(type, route, response2, end, args);
      if (type === "action") {
        actionLog(`${chalk2.blueBright(route.id)} triggered - ${chalk2.white(`${end} ms`)}`);
      } else {
        loaderLog(`${chalk2.blueBright(route.id)} triggered - ${chalk2.white(`${end} ms`)}`);
      }
      analyzeDeferred(route.id, start, response2);
      analyzeHeaders(route, response2);
    });
    return response2;
  }).catch((err) => errorHandler(route.id, err));
  return response;
};

// src/server/action.ts
var asyncAction = (route, action) => asyncAnalysis(route, "action", action);
var syncAction = (route, action) => syncAnalysis(route, "action", action);
var augmentAction = (route, action) => {
  return isAsyncFunction(action) ? asyncAction(route, action) : syncAction(route, action);
};

// src/server/loader.ts
var asyncLoader = (route, loader) => asyncAnalysis(route, "loader", loader);
var syncLoader = (route, loader) => syncAnalysis(route, "loader", loader);
var augmentLoader = (route, loader) => {
  return isAsyncFunction(loader) ? asyncLoader(route, loader) : syncLoader(route, loader);
};
var augmentLoadersAndActions = (routes) => {
  return Object.entries(routes).reduce((acc, [name, route]) => {
    return {
      // biome-ignore lint/performance/noAccumulatingSpread: <explanation>
      ...acc,
      [name]: {
        ...route,
        module: {
          ...route.module,
          ...route.module.loader ? { loader: augmentLoader(route, route.module.loader) } : {},
          ...route.module.action ? { action: augmentAction(route, route.module.action) } : {}
        }
      }
    };
  }, {});
};
export {
  augmentLoadersAndActions,
  defineServerConfig
};
